<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Furniture Retail Analytics - Easy Metrics</title>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            -webkit-overflow-scrolling: touch;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
            touch-action: manipulation;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 16px;
            margin-bottom: 20px;
        }
        
        .scenario-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .scenario-dropdown-container {
            display: none;
            flex-direction: column;
            margin-bottom: 20px;
        }
        
        .dropdown-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
            font-size: 14px;
        }
        
        .scenario-dropdown {
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            font-size: 16px;
            color: #333;
            width: 100%;
            box-sizing: border-box;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            cursor: pointer;
        }
        
        .scenario-dropdown:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .scenario-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .scenario-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }
        
        .scenario-btn:hover {
            border-color: #667eea;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-section {
            display: flex;
            flex-direction: column;
        }
        
        .chart-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            margin-bottom: 20px;
            overflow-x: auto;
        }
        
        #logisticChart {
            display: block;
            margin: 0 auto;
            touch-action: pan-x pan-y;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .interpretation-panel {
            background: #e8f4f8;
            border-radius: 12px;
            padding: 20px;
            border-left: 5px solid #667eea;
        }
        
        .interpretation-title {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }
        
        .dynamic-explanation {
            font-size: 16px;
            line-height: 1.6;
            color: #555;
        }
        
        .highlight {
            background: rgba(102, 126, 234, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .discovery-zone {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .discovery-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .discovery-zone:hover::before {
            left: 100%;
        }
        
        .discovery-zone strong {
            color: white;
            font-size: 16px;
            margin-right: 8px;
            display: inline-block;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-3px);
            }
            60% {
                transform: translateY(-2px);
            }
        }
        
        .controls-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }
        
        .control-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            margin: 15px 0;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .value-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
        }
        
        .value-number {
            font-weight: 600;
            color: #667eea;
        }
        
        .value-meaning {
            color: #666;
            font-style: italic;
        }
        
        .prediction-tool {
            background: #f0f8f0;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #28a745;
        }
        
        .prediction-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #155724;
        }
        
        .prediction-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .prediction-input input {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            -webkit-appearance: none;
        }
        
        .prediction-result {
            font-size: 16px;
            font-weight: 600;
            padding: 12px;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 6px;
            text-align: center;
        }
        
        .insights-panel {
            background: #fff3cd;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #ffc107;
        }
        
        .insights-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #856404;
        }
        
        .insight-item {
            margin-bottom: 8px;
            font-size: 14px;
            color: #856404;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
            font-size: 13px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            width: 100%;
            transition: transform 0.2s;
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        button:hover {
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Mobile Optimizations */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                margin: 0;
                border-radius: 15px;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            .header {
                margin-bottom: 20px;
            }
            
            h1 {
                font-size: 24px;
                margin-bottom: 8px;
            }
            
            .subtitle {
                font-size: 14px;
                margin-bottom: 15px;
            }
            
            .scenario-selector {
                display: none;
            }
            
            .scenario-dropdown-container {
                display: flex;
                margin-bottom: 15px;
            }
            
            .discovery-zone {
                padding: 12px;
                margin-bottom: 12px;
                font-size: 12px;
                width: 100%;
                box-sizing: border-box;
                border-radius: 6px;
            }
            
            .main-layout {
                grid-template-columns: 1fr;
                gap: 15px;
                margin-bottom: 15px;
                width: 100%;
            }
            
            .chart-section {
                width: 100%;
                min-width: 0;
            }
            
            .chart-container {
                padding: 15px;
                border-radius: 10px;
                margin-bottom: 15px;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            #logisticChart {
                width: 100% !important;
                max-width: 100% !important;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Furniture Retail Analytics</h1>
            <p class="subtitle">Track simple metrics that any employee can measure</p>
            
            <div class="scenario-selector">
                <div class="scenario-btn active" onclick="setScenario('time')" data-scenario="time" role="button" tabindex="0">
                    ⏰ Time Magic
                </div>
                <div class="scenario-btn" onclick="setScenario('dayweek')" data-scenario="dayweek" role="button" tabindex="0">
                    📅 Weekly Rhythms
                </div>
                <div class="scenario-btn" onclick="setScenario('groupsize')" data-scenario="groupsize" role="button" tabindex="0">
                    🔄 Visit Journey
                </div>
                <div class="scenario-btn" onclick="setScenario('touched')" data-scenario="touched" role="button" tabindex="0">
                    👆 Touch Factor
                </div>
            </div>
            
            <div class="scenario-dropdown-container">
                <label for="scenarioDropdown" class="dropdown-label">Choose Scenario:</label>
                <select id="scenarioDropdown" class="scenario-dropdown" onchange="setScenarioFromDropdown(this.value)">
                    <option value="time">⏰ Time Magic</option>
                    <option value="dayweek">📅 Weekly Rhythms</option>
                    <option value="groupsize">🔄 Visit Journey</option>
                    <option value="touched">👆 Touch Factor</option>
                </select>
            </div>
        </div>
        
        <div class="main-layout">
            <div class="chart-section">
                <div class="discovery-zone">
                    <strong id="discoveryIcon">🔍</strong> <span id="discoveryText">Business hours magic from 11am to 7pm - when do customers convert best?</span>
                </div>
                
                <div class="chart-container">
                    <canvas id="logisticChart" width="800" height="500"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #dc3545;"></div>
                            <span id="legendNegative">Browses Only</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #007bff;"></div>
                            <span>Prediction Curve</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(0,123,255,0.2);"></div>
                            <span>Uncertainty Range</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(220,53,69,0.4);"></div>
                            <span id="legendNegativeHist">Browses Only Cases</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(40,167,69,0.4);"></div>
                            <span id="legendPositiveHist">Purchases Cases</span>
                        </div>
                    </div>
                </div>
                
                <div class="interpretation-panel">
                    <div class="interpretation-title">What This Chart Shows</div>
                    <div class="dynamic-explanation" id="dynamicExplanation">
                        This chart shows how simple metrics can predict customer behavior in your furniture store.
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="control-group">
                    <label class="control-label">Baseline Rate</label>
                    <div class="control-description">How common is the positive outcome when factors are average?</div>
                    <input type="range" id="interceptSlider" min="-2" max="2" step="0.1" value="0">
                    <div class="value-display">
                        <span class="value-number" id="interceptValue">50%</span>
                        <span class="value-meaning" id="interceptMeaning">Balanced</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Relationship Strength</label>
                    <div class="control-description">How much does the factor influence the outcome?</div>
                    <input type="range" id="slopeSlider" min="-2" max="2" step="0.1" value="1">
                    <div class="value-display">
                        <span class="value-number" id="slopeValue">Strong</span>
                        <span class="value-meaning" id="slopeMeaning">Positive effect</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Data Amount</label>
                    <div class="control-description">How many cases do we have?</div>
                    <input type="range" id="sampleSlider" min="50" max="500" step="25" value="200">
                    <div class="value-display">
                        <span class="value-number" id="sampleValue">200</span>
                        <span class="value-meaning">Good sample</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Data Noise</label>
                    <div class="control-description">How much random variation is there?</div>
                    <input type="range" id="noiseSlider" min="0.1" max="2" step="0.1" value="0.5">
                    <div class="value-display">
                        <span class="value-number" id="noiseValue">Moderate</span>
                        <span class="value-meaning" id="noiseMeaning">Some uncertainty</span>
                    </div>
                </div>
                
                <button onclick="generateNewData()">🎲 Total Chaos Mode!</button>
                
                <div class="prediction-tool">
                    <div class="prediction-title">🎯 Make a Prediction</div>
                    <div class="prediction-input">
                        <span id="predictionLabel">Hour (24-hour):</span>
                        <input type="number" id="predictionInput" value="15" step="1" min="11" max="19">
                    </div>
                    <div class="prediction-result" id="predictionResult">
                        Probability: 73%
                    </div>
                </div>
                
                <div class="insights-panel">
                    <div class="insights-title">🔥 Hot Takes & Discoveries</div>
                    <div id="insightsList">
                        <div class="insight-item">• The curve shows the probability relationship</div>
                        <div class="insight-item">• Bars show actual data distribution</div>
                        <div class="insight-item">• Blue area shows uncertainty</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let canvas = document.getElementById('logisticChart');
        let ctx = canvas.getContext('2d');
        let data = [];
        let intercept = 0;
        let slope = 1;
        let sampleSize = 200;
        let noiseLevel = 0.5;
        let currentScenario = 'time';
        
        // Scenario configurations
        const scenarios = {
            time: {
                title: "Time Magic",
                xLabel: "Hour of Day",
                yLabel: "Makes Purchase",
                positiveLabel: "Purchases",
                negativeLabel: "Browses Only",
                predictionLabel: "Time:",
                description: "predicting purchase likelihood based on the magic hour when customers visit",
                xMin: 11,
                xMax: 19,
                xDefault: 15,
                xStep: 1
            },
            dayweek: {
                title: "Weekly Rhythms", 
                xLabel: "Day of Week",
                yLabel: "Requests Delivery",
                positiveLabel: "Delivery",
                negativeLabel: "Pickup",
                predictionLabel: "Day (1=Mon, 7=Sun):",
                description: "predicting delivery requests based on weekly shopping rhythms and customer psychology",
                xMin: 1,
                xMax: 7,
                xDefault: 4,
                xStep: 1
            },
            groupsize: {
                title: "Visit Journey",
                xLabel: "Store Visits",
                yLabel: "Makes Purchase", 
                positiveLabel: "Purchases",
                negativeLabel: "Still Browsing",
                predictionLabel: "Visit number:",
                description: "predicting purchase probability based on how many times customers have visited your store",
                xMin: 1,
                xMax: 8,
                xDefault: 3,
                xStep: 1
            },
            touched: {
                title: "Touch Factor",
                xLabel: "Items Touched/Examined",
                yLabel: "Makes Purchase",
                positiveLabel: "Purchases", 
                negativeLabel: "Leaves",
                predictionLabel: "Items examined:",
                description: "predicting purchases through tactile engagement - the surprising power of physical interaction",
                xMin: 0,
                xMax: 12,
                xDefault: 4,
                xStep: 2
            }
        };
        
        // Conversion functions between internal scale and display scale
        function convertToDisplayValue(internalX) {
            const scenario = scenarios[currentScenario];
            const normalizedX = (internalX + 4) / 8; // Convert -4,4 to 0,1
            return scenario.xMin + normalizedX * (scenario.xMax - scenario.xMin);
        }
        
        function convertFromDisplayValue(displayX) {
            const scenario = scenarios[currentScenario];
            const normalizedX = (displayX - scenario.xMin) / (scenario.xMax - scenario.xMin); // Convert to 0,1
            return normalizedX * 8 - 4; // Convert 0,1 to -4,4
        }
        
        // Set canvas size with mobile responsiveness
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40;
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            const maxWidth = Math.min(containerWidth, isMobile ? 360 : 800);
            
            if (isSmallMobile) {
                canvas.width = Math.max(280, maxWidth);
                canvas.height = 220;
            } else if (isMobile) {
                canvas.width = Math.max(320, maxWidth);
                canvas.height = 280;
            } else {
                canvas.width = Math.min(800, containerWidth);
                canvas.height = 500;
            }
            
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
            canvas.style.maxWidth = '100%';
            
            if (data.length > 0) {
                draw();
            }
        }
        
        resizeCanvas();
        
        function updateDiscoveryMessage() {
            const scenario = scenarios[currentScenario];
            const absSlope = Math.abs(slope);
            const baseline = logisticFunction(0) * 100;
            const slopeDirection = slope > 0 ? "increases" : slope < 0 ? "decreases" : "stays flat";
            
            let icon, message;
            
            const icons = ['🔍', '⚡', '🎯', '🚀', '💡', '🎉', '🤯', '🔥', '✨', '🎪'];
            
            if (Math.abs(slope) < 0.1) {
                icon = '🤔';
                const puzzleMessages = [
                    `Hmm, ${scenario.xLabel.toLowerCase()} barely affects ${scenario.positiveLabel.toLowerCase()} rates - that's unexpected!`,
                    `Plot twist! This factor isn't as important as we thought it would be...`,
                    `Interesting... the curve is almost flat. Maybe this isn't the magic variable after all?`,
                    `Wait, what? This relationship is weaker than my morning coffee! 😅`
                ];
                message = puzzleMessages[Math.floor(Math.random() * puzzleMessages.length)];
            } else if (absSlope > 1.5) {
                icon = '🤯';
                const strongMessages = [
                    `WHOA! This is a super strong relationship - ${scenario.xLabel.toLowerCase()} dramatically ${slopeDirection} success!`,
                    `Holy data points! This curve is STEEP - we found a powerful predictor!`,
                    `This is what I call a data goldmine! Look at that dramatic ${slopeDirection === 'increases' ? 'climb' : 'drop'}!`,
                    `Mind = blown! 🧠💥 This factor has serious predictive power!`
                ];
                message = strongMessages[Math.floor(Math.random() * strongMessages.length)];
            } else if (baseline > 80) {
                icon = '🎉';
                const highBaselineMessages = [
                    `Sweet! High baseline rate means customers are already primed for ${scenario.positiveLabel.toLowerCase()}!`,
                    `Excellent news - even average conditions lead to ${baseline.toFixed(0)}% ${scenario.positiveLabel.toLowerCase()} rate!`,
                    `This is what success looks like - most customers are already doing what we want!`
                ];
                message = highBaselineMessages[Math.floor(Math.random() * highBaselineMessages.length)];
            } else if (baseline < 20) {
                icon = '🎯';
                const lowBaselineMessages = [
                    `Challenge accepted! Low baseline means huge opportunity to optimize ${scenario.xLabel.toLowerCase()}!`,
                    `Ooh, this is where the magic happens - lots of room for improvement!`,
                    `Perfect! Low baseline gives us space to work with - let's find the sweet spots!`
                ];
                message = lowBaselineMessages[Math.floor(Math.random() * lowBaselineMessages.length)];
            } else if (noiseLevel > 1.5) {
                icon = '🎪';
                const noisyMessages = [
                    `Wild data circus! 🎪 High noise means our predictions are less certain, but patterns still emerge!`,
                    `Messy data = real data! This noise is totally normal in the wild world of retail!`,
                    `Embrace the chaos! Even with all this variability, we can still see the underlying trend!`
                ];
                message = noisyMessages[Math.floor(Math.random() * noisyMessages.length)];
            } else if (noiseLevel < 0.3) {
                icon = '✨';
                const cleanMessages = [
                    `Pristine data alert! ✨ This clean pattern makes predictions super reliable!`,
                    `Beautiful! This clean curve means we can trust our predictions with confidence!`,
                    `Chef's kiss to this data quality! 👨‍🍳💋 Clear patterns = reliable insights!`
                ];
                message = cleanMessages[Math.floor(Math.random() * cleanMessages.length)];
            } else {
                const scenarioMessages = {
                    time: [
                        `Business hours magic! Watch how purchase probability ${slopeDirection} from 11am to 7pm!`,
                        `Chronobiology in action! Customer buying mood literally changes throughout the business day!`,
                        `Time-based patterns are retail gold - some hours are just magical for sales! ⏰✨`,
                        `Peak hours vs. quiet times - the data reveals when customers are most ready to buy!`
                    ],
                    dayweek: [
                        `Days of the week have personality! ${slope > 0 ? 'Weekend warriors' : 'Weekday winners'} dominate here!`,
                        `Weekly rhythms reveal customer psychology - fascinating behavioral patterns!`,
                        `Calendar psychology is real! People's preferences literally shift by day of the week! 📅`
                    ],
                    groupsize: [
                        `Customer journey magic! ${slope > 0 ? 'Each visit builds commitment' : 'Sometimes first impressions win'}!`,
                        `Visit patterns reveal purchase psychology - patience vs. impulse buying!`,
                        `The power of return customers! Multiple touchpoints ${slope > 0 ? 'build trust' : 'can create hesitation'}! 🔄`,
                        `Customer loyalty metrics in action - tracking the path from browser to buyer!`
                    ],
                    touched: [
                        `Tactile engagement predicts commitment! Touch = emotional connection = sales!`,
                        `The more they touch, the more they ${slope > 0 ? 'buy' : 'browse'}! Physical interaction matters!`,
                        `Hands-on exploration reveals customer intent - this is behavioral economics in action! 👆`
                    ]
                };
                
                const currentMessages = scenarioMessages[currentScenario];
                message = currentMessages[Math.floor(Math.random() * currentMessages.length)];
                icon = icons[Math.floor(Math.random() * icons.length)];
            }
            
            const iconEl = document.getElementById('discoveryIcon');
            const textEl = document.getElementById('discoveryText');
            
            if (iconEl && textEl) {
                iconEl.textContent = icon;
                textEl.textContent = message;
            }
        }
        
        function setScenarioFromDropdown(scenarioKey) {
            setScenario(scenarioKey);
        }
        
        function setScenario(scenarioKey) {
            currentScenario = scenarioKey;
            
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`[data-scenario="${scenarioKey}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
            
            const dropdown = document.getElementById('scenarioDropdown');
            if (dropdown) {
                dropdown.value = scenarioKey;
            }
            
            updateScenarioLabels();
            updateDynamicExplanation();
            updatePrediction();
            
            const scenario = scenarios[currentScenario];
            const iconEl = document.getElementById('discoveryIcon');
            const textEl = document.getElementById('discoveryText');
            
            if (iconEl && textEl) {
                iconEl.textContent = '🔄';
                textEl.textContent = `Switching gears to ${scenario.title.toLowerCase()}... let's explore this angle!`;
                setTimeout(updateDiscoveryMessage, 800);
            }
            
            generateData();
            draw();
        }
        
        function updateScenarioLabels() {
            const scenario = scenarios[currentScenario];
            
            const legendNegativeEl = document.getElementById('legendNegative');
            const legendNegativeHistEl = document.getElementById('legendNegativeHist');
            const legendPositiveHistEl = document.getElementById('legendPositiveHist');
            const predictionLabelEl = document.getElementById('predictionLabel');
            const predictionInputEl = document.getElementById('predictionInput');
            
            if (legendNegativeEl) legendNegativeEl.textContent = scenario.negativeLabel;
            if (legendNegativeHistEl) legendNegativeHistEl.textContent = scenario.negativeLabel + ' Cases';
            if (legendPositiveHistEl) legendPositiveHistEl.textContent = scenario.positiveLabel + ' Cases';
            if (predictionLabelEl) predictionLabelEl.textContent = scenario.predictionLabel;
            
            if (predictionInputEl) {
                predictionInputEl.min = scenario.xMin;
                predictionInputEl.max = scenario.xMax;
                predictionInputEl.step = scenario.xStep;
                predictionInputEl.value = scenario.xDefault;
            }
        }
        
        function setupEventListeners() {
            const interceptSlider = document.getElementById('interceptSlider');
            const slopeSlider = document.getElementById('slopeSlider');
            const sampleSlider = document.getElementById('sampleSlider');
            const noiseSlider = document.getElementById('noiseSlider');
            const predictionInput = document.getElementById('predictionInput');
            
            if (interceptSlider) {
                interceptSlider.addEventListener('input', function() {
                    intercept = parseFloat(this.value);
                    updateAllDisplays();
                    setTimeout(updateDiscoveryMessage, 150);
                    draw();
                });
            }
            
            if (slopeSlider) {
                slopeSlider.addEventListener('input', function() {
                    slope = parseFloat(this.value);
                    updateAllDisplays();
                    setTimeout(updateDiscoveryMessage, 200);
                    draw();
                });
            }
            
            if (sampleSlider) {
                sampleSlider.addEventListener('input', function() {
                    sampleSize = parseInt(this.value);
                    const sampleValueEl = document.getElementById('sampleValue');
                    if (sampleValueEl) {
                        sampleValueEl.textContent = sampleSize;
                    }
                    generateData();
                    updateAllDisplays();
                    draw();
                });
            }
            
            if (noiseSlider) {
                noiseSlider.addEventListener('input', function() {
                    noiseLevel = parseFloat(this.value);
                    updateAllDisplays();
                    generateData();
                    setTimeout(updateDiscoveryMessage, 100);
                    draw();
                });
            }
            
            if (predictionInput) {
                predictionInput.addEventListener('input', function() {
                    updatePrediction();
                });
            }
        }
        
        function updateAllDisplays() {
            updateInterceptDisplay();
            updateSlopeDisplay();
            updateNoiseDisplay();
            updateDynamicExplanation();
            updateInsights();
            updatePrediction();
            updateDiscoveryMessage();
        }
        
        function updateInterceptDisplay() {
            const probability = logisticFunction(0) * 100;
            const interceptValueEl = document.getElementById('interceptValue');
            const interceptMeaningEl = document.getElementById('interceptMeaning');
            
            if (interceptValueEl) {
                interceptValueEl.textContent = probability.toFixed(0) + '%';
            }
            
            let meaning;
            if (probability < 20) meaning = "Very rare";
            else if (probability < 40) meaning = "Uncommon"; 
            else if (probability < 60) meaning = "Balanced";
            else if (probability < 80) meaning = "Common";
            else meaning = "Very common";
            
            if (interceptMeaningEl) {
                interceptMeaningEl.textContent = meaning;
            }
        }
        
        function updateSlopeDisplay() {
            const absSlope = Math.abs(slope);
            let strength, direction;
            
            if (absSlope < 0.3) strength = "Weak";
            else if (absSlope < 0.8) strength = "Moderate";
            else if (absSlope < 1.5) strength = "Strong";
            else strength = "Very Strong";
            
            direction = slope > 0 ? "Positive effect" : slope < 0 ? "Negative effect" : "No effect";
            
            const slopeValueEl = document.getElementById('slopeValue');
            const slopeMeaningEl = document.getElementById('slopeMeaning');
            
            if (slopeValueEl) {
                slopeValueEl.textContent = strength;
            }
            if (slopeMeaningEl) {
                slopeMeaningEl.textContent = direction;
            }
        }
        
        function updateNoiseDisplay() {
            let level, meaning;
            if (noiseLevel < 0.5) {
                level = "Low";
                meaning = "Clear pattern";
            } else if (noiseLevel < 1) {
                level = "Moderate"; 
                meaning = "Some uncertainty";
            } else if (noiseLevel < 1.5) {
                level = "High";
                meaning = "Noisy data";
            } else {
                level = "Very High";
                meaning = "Very uncertain";
            }
            
            const noiseValueEl = document.getElementById('noiseValue');
            const noiseMeaningEl = document.getElementById('noiseMeaning');
            
            if (noiseValueEl) {
                noiseValueEl.textContent = level;
            }
            if (noiseMeaningEl) {
                noiseMeaningEl.textContent = meaning;
            }
        }
        
        function updateDynamicExplanation() {
            const scenario = scenarios[currentScenario];
            const slopeDirection = slope > 0 ? "increases" : slope < 0 ? "decreases" : "doesn't budge";
            const strength = Math.abs(slope) > 1.5 ? "dramatically" : Math.abs(slope) > 1 ? "significantly" : Math.abs(slope) > 0.5 ? "moderately" : "slightly";
            const baseline = logisticFunction(0) * 100;
            
            let explanation = `This chart reveals ${scenario.description}. `;
            
            if (Math.abs(slope) < 0.1) {
                explanation += `Plot twist! The ${scenario.xLabel.toLowerCase()} has <span class="highlight">almost zero effect</span> on outcomes - sometimes the data surprises us! `;
            } else {
                const enthusiasm = Math.abs(slope) > 1 ? "Look at this! " : "";
                explanation += `${enthusiasm}As ${scenario.xLabel.toLowerCase()} increases, the probability of "${scenario.positiveLabel}" <span class="highlight">${slopeDirection} ${strength}</span>. `;
            }
            
            explanation += `Starting from average conditions, we're looking at a <span class="highlight">${baseline.toFixed(0)}% baseline chance</span>. `;
            
            if (noiseLevel > 1.5) {
                explanation += `The data shows <span class="highlight">real-world messiness</span> - predictions are uncertain, but hey, that's retail life! `;
            } else if (noiseLevel < 0.5) {
                explanation += `This data is <span class="highlight">beautifully clean</span> - our predictions are rock solid! `;
            } else {
                explanation += `We've got <span class="highlight">typical variability</span> here - exactly what you'd expect in the wild world of customer behavior. `;
            }
            
            const accuracy = calculateAccuracy();
            if (accuracy > 85) {
                explanation += `<strong>Bonus insight:</strong> This model is crushing it with ${accuracy.toFixed(0)}% accuracy! 🎯`;
            } else if (accuracy < 60) {
                explanation += `<strong>Reality check:</strong> Only ${accuracy.toFixed(0)}% accuracy - there's more to the story than just this factor.`;
            }
            
            const explanationEl = document.getElementById('dynamicExplanation');
            if (explanationEl) {
                explanationEl.innerHTML = explanation;
            }
        }
        
        function updateInsights() {
            const accuracy = calculateAccuracy();
            const scenario = scenarios[currentScenario];
            
            let insights = [];
            
            if (Math.abs(slope) > 1.5) {
                insights.push("🚀 JACKPOT! This factor is a powerhouse predictor!");
            } else if (Math.abs(slope) > 1) {
                insights.push("⭐ Strong signal detected - this factor really matters!");
            } else if (Math.abs(slope) > 0.5) {
                insights.push("📊 Decent relationship - this factor has some predictive juice!");
            } else if (Math.abs(slope) < 0.1) {
                insights.push("🤷 Mystery solved: this factor barely moves the needle!");
            } else {
                insights.push("📈 Weak but measurable - every little insight counts!");
            }
            
            if (accuracy > 85) {
                insights.push("🎯 Model accuracy is through the roof - we nailed it!");
            } else if (accuracy > 75) {
                insights.push("✅ Solid accuracy - this model knows what it's doing!");
            } else if (accuracy > 60) {
                insights.push("⚖️ Decent accuracy - room for improvement but useful!");
            } else {
                insights.push("🎲 Low accuracy alert - life is complex, predictions are hard!");
            }
            
            if (sampleSize > 400) {
                insights.push("📈 Massive dataset = rock-solid confidence levels!");
            } else if (sampleSize > 200) {
                insights.push("👍 Good sample size - our findings are trustworthy!");
            } else if (sampleSize < 100) {
                insights.push("⚠️ Small sample - take these results with a grain of salt!");
            }
            
            if (currentScenario === 'time' && Math.abs(slope) > 0.5) {
                insights.push(slope > 0 ? "⏰ Afternoon and evening customers are your gold mine - staff up for closing time!" : "🌅 Morning shoppers need different attention - optimize your 11am-noon strategy!");
            } else if (currentScenario === 'groupsize' && Math.abs(slope) > 0.5) {
                insights.push(slope > 0 ? "🔄 Return customers are gold! Focus on nurturing repeat visitors!" : "⚡ First-visit conversions matter most - optimize that initial experience!");
            } else if (currentScenario === 'touched' && Math.abs(slope) > 0.5) {
                insights.push("👋 Encourage touching! Tactile engagement drives behavior!");
            }
            
            const insightsEl = document.getElementById('insightsList');
            if (insightsEl) {
                insightsEl.innerHTML = insights.join('<br>');
            }
        }
        
        function updatePrediction() {
            const inputEl = document.getElementById('predictionInput');
            const resultEl = document.getElementById('predictionResult');
            
            if (!inputEl || !resultEl) return;
            
            const displayValue = parseFloat(inputEl.value) || 0;
            const internalValue = convertFromDisplayValue(displayValue);
            const probability = logisticFunction(internalValue) * 100;
            const scenario = scenarios[currentScenario];
            
            let interpretation;
            if (probability > 80) interpretation = "Very Likely";
            else if (probability > 60) interpretation = "Likely";
            else if (probability > 40) interpretation = "Uncertain";
            else if (probability > 20) interpretation = "Unlikely";
            else interpretation = "Very Unlikely";
            
            resultEl.innerHTML = 
                `<strong>${probability.toFixed(0)}% chance</strong><br><small>${interpretation} to be "${scenario.positiveLabel}"</small>`;
        }
        
        function generateData() {
            data = [];
            for (let i = 0; i < sampleSize; i++) {
                const x = (Math.random() - 0.5) * 8;
                const logit = intercept + slope * x + (Math.random() - 0.5) * noiseLevel * 2;
                const probability = 1 / (1 + Math.exp(-logit));
                const y = Math.random() < probability ? 1 : 0;
                data.push({ x, y, probability });
            }
        }
        
        function generateNewData() {
            // Randomize all the parameters for maximum chaos!
            intercept = (Math.random() - 0.5) * 4; // -2 to 2
            slope = (Math.random() - 0.5) * 4; // -2 to 2  
            sampleSize = Math.floor(Math.random() * 450) + 50; // 50 to 500
            noiseLevel = Math.random() * 1.9 + 0.1; // 0.1 to 2
            
            // Update all the sliders to reflect the new random values
            const interceptSlider = document.getElementById('interceptSlider');
            const slopeSlider = document.getElementById('slopeSlider');
            const sampleSlider = document.getElementById('sampleSlider');
            const noiseSlider = document.getElementById('noiseSlider');
            
            if (interceptSlider) interceptSlider.value = intercept;
            if (slopeSlider) slopeSlider.value = slope;
            if (sampleSlider) sampleSlider.value = sampleSize;
            if (noiseSlider) noiseSlider.value = noiseLevel;
            
            // Generate fresh data with the new random parameters
            generateData();
            updateAllDisplays();
            
            // Add some excitement to the discovery message
            const iconEl = document.getElementById('discoveryIcon');
            const textEl = document.getElementById('discoveryText');
            
            if (iconEl && textEl) {
                iconEl.textContent = '🎲';
                const chaosMessages = [
                    'Complete chaos mode activated! New data, new parameters, new discoveries ahead...',
                    'Rolling ALL the dice! Fresh data, random settings, maximum experimentation!',
                    'Everything randomized! Let\'s see what wild patterns emerge from this chaos!',
                    'Total parameter mayhem! Buckle up for some surprising discoveries!'
                ];
                textEl.textContent = chaosMessages[Math.floor(Math.random() * chaosMessages.length)];
                
                // Update to actual discovery after a brief moment
                setTimeout(updateDiscoveryMessage, 1200);
            }
            
            draw();
        }
        
        function logisticFunction(x) {
            return 1 / (1 + Math.exp(-(intercept + slope * x)));
        }
        
        function calculateAccuracy() {
            let correct = 0;
            for (let point of data) {
                const predicted = logisticFunction(point.x) > 0.5 ? 1 : 0;
                if (predicted === point.y) correct++;
            }
            return (correct / data.length * 100);
        }
        
        function draw() {
            const width = canvas.width;
            const height = canvas.height;
            const isMobile = window.innerWidth <= 768;
            const leftMargin = isMobile ? 65 : 90;  // Increased left margin for labels
            const rightMargin = isMobile ? 40 : 60;
            const topMargin = isMobile ? 40 : 60;
            const bottomMargin = isMobile ? 40 : 60;
            const plotWidth = width - leftMargin - rightMargin;
            const plotHeight = height - topMargin - bottomMargin;
            
            const scenario = scenarios[currentScenario];
            const xMin = scenario.xMin;
            const xMax = scenario.xMax;
            const yMin = -0.1, yMax = 1.1;
            
            ctx.clearRect(0, 0, width, height);
            
            function xToCanvas(x) {
                return leftMargin + ((x - xMin) / (xMax - xMin)) * plotWidth;
            }
            
            function yToCanvas(y) {
                return height - bottomMargin - ((y - yMin) / (yMax - yMin)) * plotHeight;
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(leftMargin, topMargin, plotWidth, plotHeight);
            
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            const xStep = scenario.xStep;
            for (let x = xMin; x <= xMax; x += xStep) {
                const canvasX = xToCanvas(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, topMargin);
                ctx.lineTo(canvasX, height - bottomMargin);
                ctx.stroke();
            }
            
            for (let y = 0; y <= 1; y += 0.25) {
                const canvasY = yToCanvas(y);
                ctx.beginPath();
                ctx.moveTo(leftMargin, canvasY);
                ctx.lineTo(width - rightMargin, canvasY);
                ctx.stroke();
            }
            
            // Calculate appropriate number of bins - ensure it's always a valid integer
            let bins = Math.floor(Math.min(30, xMax - xMin + 1));
            bins = Math.max(bins, 5); // Ensure at least 5 bins for meaningful display
            const binWidth = (xMax - xMin) / bins;
            const binCounts = { 0: new Array(bins).fill(0), 1: new Array(bins).fill(0) };
            
            for (let point of data) {
                const displayX = convertToDisplayValue(point.x);
                const binIndex = Math.floor((displayX - xMin) / binWidth);
                if (binIndex >= 0 && binIndex < bins) {
                    binCounts[point.y][binIndex]++;
                }
            }
            
            const maxCount = Math.max(...binCounts[0], ...binCounts[1]);
            const histScale = 0.25;
            const middleY = yToCanvas(0.5);
            
            if (maxCount > 0) {
                for (let i = 0; i < bins; i++) {
                    const x1 = xMin + i * binWidth;
                    const x2 = x1 + binWidth;
                    const canvasX1 = xToCanvas(x1);
                    const canvasX2 = xToCanvas(x2);
                    const barWidth = canvasX2 - canvasX1;
                    
                    if (binCounts[0][i] > 0) {
                        const barHeight = (binCounts[0][i] / maxCount) * histScale * plotHeight;
                        ctx.fillStyle = 'rgba(220, 53, 69, 0.5)';
                        ctx.fillRect(canvasX1, middleY, barWidth, barHeight);
                    }
                    
                    if (binCounts[1][i] > 0) {
                        const barHeight = (binCounts[1][i] / maxCount) * histScale * plotHeight;
                        ctx.fillStyle = 'rgba(40, 167, 69, 0.5)';
                        ctx.fillRect(canvasX1, middleY - barHeight, barWidth, barHeight);
                    }
                }
            }
            
            ctx.fillStyle = 'rgba(0, 123, 255, 0.15)';
            ctx.beginPath();
            const step = (xMax - xMin) / 100;
            for (let displayX = xMin; displayX <= xMax; displayX += step) {
                const internalX = convertFromDisplayValue(displayX);
                const p = logisticFunction(internalX);
                const se = Math.sqrt(p * (1 - p) / Math.max(10, sampleSize / 20));
                const upperCI = Math.min(1, p + 1.96 * se);
                
                if (displayX === xMin) {
                    ctx.moveTo(xToCanvas(displayX), yToCanvas(upperCI));
                } else {
                    ctx.lineTo(xToCanvas(displayX), yToCanvas(upperCI));
                }
            }
            for (let displayX = xMax; displayX >= xMin; displayX -= step) {
                const internalX = convertFromDisplayValue(displayX);
                const p = logisticFunction(internalX);
                const se = Math.sqrt(p * (1 - p) / Math.max(10, sampleSize / 20));
                const lowerCI = Math.max(0, p - 1.96 * se);
                ctx.lineTo(xToCanvas(displayX), yToCanvas(lowerCI));
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = isMobile ? 3 : 4;
            ctx.beginPath();
            for (let displayX = xMin; displayX <= xMax; displayX += step) {
                const internalX = convertFromDisplayValue(displayX);
                const y = logisticFunction(internalX);
                const canvasX = xToCanvas(displayX);
                const canvasY = yToCanvas(y);
                
                if (displayX === xMin) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            const pointRadius = isMobile ? 3 : 4;
            for (let point of data) {
                const displayX = convertToDisplayValue(point.x);
                const canvasX = xToCanvas(displayX);
                const baseY = point.y === 1 ? 1 : 0;
                const jitter = (Math.random() - 0.5) * 0.06;
                const canvasY = yToCanvas(baseY + jitter);
                
                ctx.fillStyle = point.y === 1 ? '#28a745' : '#dc3545';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = isMobile ? 1 : 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(leftMargin, yToCanvas(0.5));
            ctx.lineTo(width - rightMargin, yToCanvas(0.5));
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = isMobile ? 1 : 2;
            
            ctx.beginPath();
            ctx.moveTo(leftMargin, height - bottomMargin);
            ctx.lineTo(width - rightMargin, height - bottomMargin);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftMargin, topMargin);
            ctx.lineTo(leftMargin, height - bottomMargin);
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = isMobile ? '10px Inter' : '14px Inter';
            ctx.textAlign = 'center';
            
            let labelStep = xStep;
            if (isMobile) {
                if (currentScenario === 'time') {
                    labelStep = 1; // Show hourly labels on mobile for time
                } else if ((xMax - xMin) > 5) {
                    labelStep = xStep * 2;
                }
            }
            for (let x = xMin; x <= xMax; x += labelStep) {
                // For time scenario on mobile, only show labels at integer hours
                if (currentScenario === 'time' && isMobile && x % 1 !== 0) {
                    continue;
                }
                
                const canvasX = xToCanvas(x);
                let label = x.toString();
                if (currentScenario === 'time') {
                    label = x + ':00';
                } else if (currentScenario === 'dayweek') {
                    const days = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                    label = days[x] || x.toString();
                } else if (currentScenario === 'groupsize') {
                    label = isMobile ? x.toString() : x + (x === 1 ? ' visit' : ' visits');
                } else if (currentScenario === 'touched') {
                    label = isMobile ? x.toString() : x + ' items';
                }
                ctx.fillText(label, canvasX, height - bottomMargin + (isMobile ? 18 : 25));
            }
            
            // Draw Y-axis labels with outcome names instead of percentages
            ctx.textAlign = 'right';
            ctx.fillText(scenario.negativeLabel, leftMargin - (isMobile ? 8 : 10), yToCanvas(0) + 3);
            ctx.fillText(scenario.positiveLabel, leftMargin - (isMobile ? 8 : 10), yToCanvas(1) + 3);
            
            ctx.font = isMobile ? '12px Inter' : '16px Inter';
            ctx.fillStyle = '#444';
            ctx.textAlign = 'center';
            
            ctx.fillText(scenario.xLabel, width / 2, height - (isMobile ? 2 : 5));
            
            ctx.save();
            ctx.translate(isMobile ? 12 : 20, height / 2);
            ctx.rotate(-Math.PI / 2);
            const yTitle = isMobile ? scenario.positiveLabel : `Probability of ${scenario.positiveLabel}`;
            ctx.fillText(yTitle, 0, 0);
            ctx.restore();
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            try {
                generateData();
                setupEventListeners();
                updateScenarioLabels();
                updateAllDisplays();
                
                const dropdown = document.getElementById('scenarioDropdown');
                if (dropdown) {
                    dropdown.value = currentScenario;
                }
                
                draw();
                
                window.addEventListener('resize', function() {
                    resizeCanvas();
                });
                
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
                
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });
        
        if (document.readyState !== 'loading') {
            try {
                generateData();
                setupEventListeners();
                updateScenarioLabels();
                updateAllDisplays();
                
                const dropdown = document.getElementById('scenarioDropdown');
                if (dropdown) {
                    dropdown.value = currentScenario;
                }
                
                draw();
                
                window.addEventListener('resize', function() {
                    resizeCanvas();
                });
                
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
                
            } catch (error) {
                console.error('Fallback initialization error:', error);
            }
        }
    </script>
</body>
</html>
